{"version":3,"file":"index.js","mappings":"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","sources":["src://tavern_helper_template/src/寒冬末日/util/time.ts","src://tavern_helper_template/src/寒冬末日/util/health.ts","src://tavern_helper_template/src/寒冬末日/脚本/离场健康结算/index.ts","src://tavern_helper_template/src/寒冬末日/util/shelter_scope.ts","src://tavern_helper_template/src/寒冬末日/util/room.ts"],"sourcesContent":["type ParsedWorldTime = {\n  epochMinutes: number;\n  hour: number;\n  minute: number;\n};\n\nfunction parseDateToEpochDay(dateStr: string): number | null {\n  // 格式：末日纪元，XXXX年XX月XX日\n  const m = (dateStr ?? '').match(/(\\d{1,4})年(\\d{1,2})月(\\d{1,2})日/);\n  if (!m) return null;\n  const year = Number(m[1]);\n  const month = Number(m[2]);\n  const day = Number(m[3]);\n  if (!Number.isFinite(year) || !Number.isFinite(month) || !Number.isFinite(day)) return null;\n  const d = new Date(year, month - 1, day);\n  if (Number.isNaN(d.getTime())) return null;\n  return Math.floor(d.getTime() / 86400000);\n}\n\nfunction parseTimeToMinutes(timeStr: string): { hour: number; minute: number } | null {\n  // 格式：时间段 - HH:MM\n  const m = (timeStr ?? '').match(/(\\d{1,2}):(\\d{2})/);\n  if (!m) return null;\n  const hour = Number(m[1]);\n  const minute = Number(m[2]);\n  if (!Number.isFinite(hour) || !Number.isFinite(minute)) return null;\n  if (hour < 0 || hour > 23 || minute < 0 || minute > 59) return null;\n  return { hour, minute };\n}\n\nexport function parseWorldTime(dateStr: string, timeStr: string): ParsedWorldTime | null {\n  const day = parseDateToEpochDay(dateStr);\n  const hm = parseTimeToMinutes(timeStr);\n  if (day === null || hm === null) return null;\n  const epochMinutes = day * 1440 + hm.hour * 60 + hm.minute;\n  return { epochMinutes, hour: hm.hour, minute: hm.minute };\n}\n\nexport function diffWorldHours(\n  oldWorld: { 日期?: string; 时间?: string },\n  newWorld: { 日期?: string; 时间?: string },\n): number | null {\n  const oldParsed = parseWorldTime(oldWorld.日期 ?? '', oldWorld.时间 ?? '');\n  const newParsed = parseWorldTime(newWorld.日期 ?? '', newWorld.时间 ?? '');\n  if (!oldParsed || !newParsed) return null;\n  const diffMinutes = newParsed.epochMinutes - oldParsed.epochMinutes;\n  if (!Number.isFinite(diffMinutes)) return null;\n  if (diffMinutes <= 0) return null;\n  return diffMinutes / 60;\n}\n","export type HealthRules = {\n  decayPer6h: number;\n  recoverPer12h: number;\n  decayMultiplier: number;\n  recoverMultiplier: number;\n};\n\nexport function clampHealth(v: number): number {\n  return _.clamp(Number(v) || 0, 0, 100);\n}\n\nexport function healthCondition(health: number): string {\n  const h = clampHealth(health);\n  if (h <= 0) return '死亡';\n  if (h < 30) return '重病/濒死';\n  if (h < 60) return '生病/受伤';\n  if (h < 80) return '亚健康';\n  return '健康';\n}\n\nexport function computeOffstageHealthDelta(\n  deltaHours: number,\n  sheltered: boolean,\n  rules: HealthRules,\n): { delta: number; reason: string } {\n  const dh = Number(deltaHours);\n  if (!Number.isFinite(dh) || dh <= 0) return { delta: 0, reason: '0, 无变化' };\n\n  const decayPer6h = Math.max(0, Number(rules.decayPer6h) || 0);\n  const recoverPer12h = Math.max(0, Number(rules.recoverPer12h) || 0);\n  const decayMultiplier = Math.max(0, Number(rules.decayMultiplier) || 0);\n  const recoverMultiplier = Math.max(0, Number(rules.recoverMultiplier) || 0);\n\n  if (sheltered) {\n    const steps = Math.floor(dh / 12);\n    const delta = Math.floor(steps * recoverPer12h * recoverMultiplier);\n    if (!delta) return { delta: 0, reason: '0, 无变化' };\n    return { delta, reason: `+${delta}, 离场受庇护休整` };\n  }\n\n  const steps = Math.floor(dh / 6);\n  const delta = -Math.floor(steps * decayPer6h * decayMultiplier);\n  if (!delta) return { delta: 0, reason: '0, 无变化' };\n  return { delta, reason: `${delta}, 离场未受庇护自然衰减` };\n}\n","import { diffWorldHours } from '../../util/time';\nimport { findRoleLocation } from '../../util/room';\nimport { normalizeScope, ShelterScopeByFloor, isRoomSheltered } from '../../util/shelter_scope';\nimport { clampHealth, computeOffstageHealthDelta, healthCondition, HealthRules } from '../../util/health';\n\ntype RoleLike = {\n  姓名?: string;\n  健康?: number;\n  健康更新原因?: string;\n  健康状况?: string;\n  登场状态?: string;\n  关系?: string;\n  关系倾向?: string;\n  秩序刻印?: number;\n  秩序刻印更新原因?: string;\n};\n\ntype RoleTouched = {\n  health: boolean;\n  healthReason: boolean;\n  relation: boolean;\n  relationTendency: boolean;\n  imprint: boolean;\n  imprintReason: boolean;\n};\n\nfunction parseTimeStrToMinutes(timeStr: string): number | null {\n  const m = (timeStr ?? '').match(/(\\d{1,2}):(\\d{2})/);\n  if (!m) return null;\n  const hour = Number(m[1]);\n  const minute = Number(m[2]);\n  if (!Number.isFinite(hour) || !Number.isFinite(minute)) return null;\n  if (hour < 0 || hour > 23 || minute < 0 || minute > 59) return null;\n  return hour * 60 + minute;\n}\n\nfunction parseDateStr(dateStr: string): { year: number; month: number; day: number } | null {\n  const m = (dateStr ?? '').match(/(\\d{1,4})年(\\d{1,2})月(\\d{1,2})日/);\n  if (!m) return null;\n  const year = Number(m[1]);\n  const month = Number(m[2]);\n  const day = Number(m[3]);\n  if (!Number.isFinite(year) || !Number.isFinite(month) || !Number.isFinite(day)) return null;\n  return { year, month, day };\n}\n\nfunction formatDateStr(date: Date): string {\n  return `末日纪元，${date.getFullYear()}年${date.getMonth() + 1}月${date.getDate()}日`;\n}\n\nfunction readDebugFlagsFromChat(): { dateLogic: boolean; offstageHealth: boolean } {\n  const vars = getVariables({ type: 'chat' }) ?? {};\n  const debug = _.get(vars, 'eden.debug', {}) ?? {};\n  return {\n    dateLogic: _.get(debug, 'date_logic', false) === true,\n    offstageHealth: _.get(debug, 'offstage_health', false) === true,\n  };\n}\n\nfunction relationStageFromImprint(mark: number): '拒绝' | '交易' | '顺从' | '忠诚' | '性奴' {\n  const v = _.clamp(Number(mark) || 0, 0, 100);\n  if (v < 20) return '拒绝';\n  if (v < 40) return '交易';\n  if (v < 60) return '顺从';\n  if (v < 90) return '忠诚';\n  return '性奴';\n}\n\nfunction readShelterScopeFromChat(): ShelterScopeByFloor {\n  const vars = getVariables({ type: 'chat' }) ?? {};\n  const raw = _.get(vars, 'eden.shelter_scope', {});\n  if (!raw || typeof raw !== 'object') return {};\n  return normalizeScope(raw as any);\n}\n\nfunction readHealthRulesFromChat(): HealthRules {\n  const vars = getVariables({ type: 'chat' }) ?? {};\n  const raw = _.get(vars, 'eden.rules.health', {}) ?? {};\n  const r = raw as Partial<HealthRules>;\n  return {\n    decayPer6h: _.clamp(Number(r.decayPer6h) || 5, 0, 10),\n    recoverPer12h: _.clamp(Number(r.recoverPer12h) || 1, 0, 10),\n    decayMultiplier: _.clamp(Number(r.decayMultiplier) || 1, 0, 10),\n    recoverMultiplier: _.clamp(Number(r.recoverMultiplier) || 1, 0, 10),\n  };\n}\n\nfunction isShelteredForRole(stat_data: any, roleName: string, scope: ShelterScopeByFloor): boolean {\n  const rooms = _.get(stat_data, '房间', {});\n  const loc = findRoleLocation(rooms, roleName);\n  if (loc.kind === 'core' || loc.kind === 'entrance') return true;\n  if (loc.kind === 'floor') {\n    if (loc.floor === '20' && loc.roomNumber === '2001') return true;\n    return isRoomSheltered(scope, loc.floor, loc.roomNumber);\n  }\n  return false;\n}\n\nfunction isRoleLike(val: any): val is RoleLike {\n  return val && typeof val === 'object' && '健康' in val && '登场状态' in val;\n}\n\nfunction diffRoleTouched(oldRole: RoleLike | null, newRole: RoleLike): RoleTouched {\n  if (!oldRole) {\n    return {\n      health: false,\n      healthReason: false,\n      relation: false,\n      relationTendency: false,\n      imprint: false,\n      imprintReason: false,\n    };\n  }\n  return {\n    health: !_.isEqual(oldRole.健康, newRole.健康),\n    healthReason: !_.isEqual(oldRole.健康更新原因, newRole.健康更新原因),\n    relation: !_.isEqual(oldRole.关系, newRole.关系),\n    relationTendency: !_.isEqual(oldRole.关系倾向, newRole.关系倾向),\n    imprint: !_.isEqual(oldRole.秩序刻印, newRole.秩序刻印),\n    imprintReason: !_.isEqual(oldRole.秩序刻印更新原因, newRole.秩序刻印更新原因),\n  };\n}\n\nfunction applyOffstageRoleHealthIfNeeded(\n  rolePath: string,\n  roleName: string,\n  oldRole: RoleLike | null,\n  newRole: RoleLike,\n  stat_data: any,\n  deltaHours: number | null,\n  scope: ShelterScopeByFloor,\n  rules: HealthRules,\n  debug?: { offstageHealth: boolean },\n) {\n  if (newRole.登场状态 !== '离场') return;\n  if (!oldRole) return;\n  if (deltaHours === null) return;\n\n  // 规则：只要 AI 本轮对“健康/健康更新原因”有指令，就认为是剧情介入，脚本不做基础结算\n  const touched = diffRoleTouched(oldRole, newRole);\n  if (touched.health || touched.healthReason) {\n    if (debug?.offstageHealth) {\n      console.log(\n        `[OffstageHealth] skip(${roleName}): touched by AI (health=${touched.health}, reason=${touched.healthReason})`,\n      );\n    }\n    return;\n  }\n\n  const currentHealth = clampHealth(Number(newRole.健康) || 0);\n  const sheltered = isShelteredForRole(stat_data, roleName, scope);\n  const computed = computeOffstageHealthDelta(deltaHours, sheltered, rules);\n  if (!computed.delta) {\n    if (debug?.offstageHealth) {\n      console.log(`[OffstageHealth] no-op(${roleName}): dh=${deltaHours.toFixed(2)}, sheltered=${sheltered}`);\n    }\n    return;\n  }\n\n  const nextHealth = clampHealth(currentHealth + computed.delta);\n  const actualDelta = nextHealth - currentHealth;\n\n  const label =\n    computed.reason.split(',').slice(1).join(',').trim() || (sheltered ? '离场受庇护休整' : '离场未受庇护自然衰减');\n  const reasonText = actualDelta ? `${actualDelta > 0 ? `+${actualDelta}` : `${actualDelta}`}, ${label}` : '0, 无变化';\n\n  _.set(stat_data, `${rolePath}.健康`, nextHealth);\n  _.set(stat_data, `${rolePath}.健康更新原因`, reasonText);\n  console.log(`[离场健康结算] ${roleName}: ${currentHealth} → ${nextHealth} (${reasonText})`);\n}\n\nfunction applyDerivedHealthStatus(rolePath: string, role: RoleLike, stat_data: any) {\n  const health = clampHealth(Number(role.健康) || 0);\n  const expected = healthCondition(health);\n  if (role.健康状况 !== expected) {\n    _.set(stat_data, `${rolePath}.健康状况`, expected);\n  }\n}\n\nfunction applyDerivedRelationStage(rolePath: string, oldRole: RoleLike | null, newRole: RoleLike, stat_data: any) {\n  const markRaw = newRole.秩序刻印;\n  if (typeof markRaw !== 'number' && typeof markRaw !== 'string') return;\n  const stage = relationStageFromImprint(Number(markRaw));\n\n  // 规则：脚本只在阈值导致阶段变化时写回关系；若 AI 本轮明确更新了关系，则不覆盖\n  const touched = diffRoleTouched(oldRole, newRole);\n  if (touched.relation) return;\n\n  if (newRole.关系 !== stage) {\n    _.set(stat_data, `${rolePath}.关系`, stage);\n  }\n}\n\n$(async () => {\n  await waitGlobalInitialized('Mvu');\n\n  eventOn(Mvu.events.VARIABLE_UPDATE_ENDED, (new_variables, old_variables) => {\n    const debug = readDebugFlagsFromChat();\n    const oldWorld = _.get(old_variables, 'stat_data.世界', {});\n\n    // 跨午夜自动补日期：避免 AI 把时间从 23:xx 推进到 01:xx 但忘记 日期/末日天数 +1，导致 diffWorldHours 判定“时间未前进”\n    // 注意：若同时部署了 `src/寒冬末日/脚本/日期逻辑/index.ts`，请二选一，避免重复 +1\n    {\n      const oldTimeStr = _.get(old_variables, 'stat_data.世界.时间', '');\n      const newTimeStr = _.get(new_variables, 'stat_data.世界.时间', '');\n      if (oldTimeStr !== newTimeStr) {\n        const oldMinutes = parseTimeStrToMinutes(oldTimeStr);\n        const newMinutes = parseTimeStrToMinutes(newTimeStr);\n        if (oldMinutes !== null && newMinutes !== null && oldMinutes > newMinutes) {\n          console.log(`[DateLogic] Detected midnight crossing: ${oldTimeStr} -> ${newTimeStr}`);\n          const oldDateStr = _.get(old_variables, 'stat_data.世界.日期', '');\n          const newDateStr = _.get(new_variables, 'stat_data.世界.日期', '');\n          if (oldDateStr === newDateStr) {\n            console.log('[DateLogic] AI did not update date, patching date/day...');\n            const parsed = parseDateStr(oldDateStr);\n            if (parsed) {\n              const dateObj = new Date(parsed.year, parsed.month - 1, parsed.day);\n              if (!Number.isNaN(dateObj.getTime())) {\n                dateObj.setDate(dateObj.getDate() + 1);\n                const patched = formatDateStr(dateObj);\n                _.set(new_variables, 'stat_data.世界.日期', patched);\n\n                const oldDays = _.get(new_variables, 'stat_data.世界.末日天数');\n                if (typeof oldDays === 'number') {\n                  _.set(new_variables, 'stat_data.世界.末日天数', oldDays + 1);\n                }\n                const daysAfter = _.get(new_variables, 'stat_data.世界.末日天数');\n                console.log(`[DateLogic] patched date: ${oldDateStr} -> ${patched}; days: ${oldDays} -> ${daysAfter}`);\n              } else if (debug.dateLogic) {\n                console.log(`[DateLogic] cannot parse date to Date(): ${oldDateStr}`);\n              }\n            } else if (debug.dateLogic) {\n              console.log(`[DateLogic] cannot parse date string: ${oldDateStr}`);\n            }\n          } else if (debug.dateLogic) {\n            console.log(`[DateLogic] date already updated by AI: ${oldDateStr} -> ${newDateStr}`);\n          }\n        } else if (debug.dateLogic) {\n          console.log(\n            `[DateLogic] time changed but not crossing: ${oldTimeStr} -> ${newTimeStr} (oldMin=${oldMinutes}, newMin=${newMinutes})`,\n          );\n        }\n      } else if (debug.dateLogic) {\n        console.log('[DateLogic] time unchanged; no date check.');\n      }\n    }\n\n    const newWorld = _.get(new_variables, 'stat_data.世界', {});\n    const deltaHours = diffWorldHours(oldWorld, newWorld);\n    if (deltaHours === null) {\n      const oldTimeStr = _.get(old_variables, 'stat_data.世界.时间', '');\n      const newTimeStr = _.get(new_variables, 'stat_data.世界.时间', '');\n      if (oldTimeStr !== newTimeStr) {\n        console.log('[DateLogic] diffWorldHours=null', { oldWorld, newWorld });\n      } else if (debug.dateLogic) {\n        console.log('[DateLogic] diffWorldHours=null (time unchanged)', { oldWorld, newWorld });\n      }\n    } else if (debug.dateLogic) {\n      console.log(`[DateLogic] diffWorldHours=${deltaHours.toFixed(2)}`);\n    }\n\n    const stat_data = _.get(new_variables, 'stat_data', {});\n    const old_stat_data = _.get(old_variables, 'stat_data', {});\n\n    const scope = readShelterScopeFromChat();\n    const rules = readHealthRulesFromChat();\n\n    const reserved = new Set(['世界', '庇护所', '房间', '主线任务', '楼层其他住户', '临时NPC']);\n    for (const [key, val] of Object.entries(stat_data ?? {})) {\n      if (reserved.has(key)) continue;\n      if (typeof key !== 'string' || key.startsWith('_')) continue;\n      if (!isRoleLike(val)) continue;\n\n      const oldRole = _.get(old_stat_data, key, null) as any as RoleLike | null;\n      applyOffstageRoleHealthIfNeeded(key, key, oldRole, val as any, stat_data, deltaHours, scope, rules, debug);\n      applyDerivedHealthStatus(key, val as any, stat_data);\n      applyDerivedRelationStage(key, oldRole, val as any, stat_data);\n    }\n\n    const tempNpc = _.get(stat_data, '临时NPC', {});\n    if (tempNpc && typeof tempNpc === 'object') {\n      for (const [name, val] of Object.entries(tempNpc)) {\n        if (typeof name !== 'string' || !name) continue;\n        if (!isRoleLike(val)) continue;\n\n        const oldRole = _.get(old_stat_data, `临时NPC.${name}`, null) as any as RoleLike | null;\n        applyOffstageRoleHealthIfNeeded(\n          `临时NPC.${name}`,\n          name,\n          oldRole,\n          val as any,\n          stat_data,\n          deltaHours,\n          scope,\n          rules,\n          debug,\n        );\n        applyDerivedHealthStatus(`临时NPC.${name}`, val as any, stat_data);\n        applyDerivedRelationStage(`临时NPC.${name}`, oldRole, val as any, stat_data);\n      }\n    }\n  });\n});\n","export type ShelterScopeByFloor = Record<string, string[]>;\n\nexport function floorRoomCapacity(level: number, floor: '20' | '19'): number {\n  const lv = Number(level);\n  if (!Number.isFinite(lv)) return 0;\n\n  if (floor === '20') {\n    // 设定：Lv3=3 间，Lv4=6 间，Lv5=12 间（封顶）\n    if (lv < 3) return 0;\n    if (lv === 3) return 3;\n    if (lv === 4) return 6;\n    return 12;\n  }\n\n  // 19 层从等级 6 开始\n  if (lv < 6) return 0;\n  return _.clamp((lv - 5) * 3, 0, 12);\n}\n\nexport function isRoomSheltered(scope: ShelterScopeByFloor, floor: '20' | '19', roomNumber: string): boolean {\n  const list = scope?.[floor] ?? [];\n  if (!Array.isArray(list)) return false;\n  return list.includes(roomNumber);\n}\n\nexport function normalizeScope(scope: ShelterScopeByFloor): ShelterScopeByFloor {\n  const out: ShelterScopeByFloor = {};\n  for (const [floor, rooms] of Object.entries(scope ?? {})) {\n    if (!Array.isArray(rooms)) continue;\n    out[floor] = _(rooms)\n      .filter((x: any) => typeof x === 'string' && x.trim())\n      .filter((room: string) => !(floor === '20' && room === '2001'))\n      .uniq()\n      .sortBy()\n      .value();\n  }\n  return out;\n}\n","export type RoomLocation =\n  | { kind: 'entrance'; room: '临时客房A' | '临时客房B' | '玄关' }\n  | { kind: 'core'; room: '主卧室' | '主浴室' }\n  | { kind: 'floor'; floor: '20' | '19'; roomNumber: string }\n  | { kind: 'none' };\n\ntype RoomsStatData = any;\n\nexport function findRoleLocation(rooms: RoomsStatData, roleName: string): RoomLocation {\n  const name = roleName ?? '';\n  if (!name) return { kind: 'none' };\n\n  const entranceA: string[] = _.get(rooms, '玄关.临时客房A入住者', []);\n  if (Array.isArray(entranceA) && entranceA.includes(name)) return { kind: 'entrance', room: '临时客房A' };\n\n  const entranceB: string[] = _.get(rooms, '玄关.临时客房B入住者', []);\n  if (Array.isArray(entranceB) && entranceB.includes(name)) return { kind: 'entrance', room: '临时客房B' };\n\n  const bedroom: string[] = _.get(rooms, '核心区.主卧室使用者', []);\n  if (Array.isArray(bedroom) && bedroom.includes(name)) return { kind: 'core', room: '主卧室' };\n\n  const bathroom: string[] = _.get(rooms, '核心区.主浴室使用者', []);\n  if (Array.isArray(bathroom) && bathroom.includes(name)) return { kind: 'core', room: '主浴室' };\n\n  const floor20: Record<string, any> = _.get(rooms, '楼层房间.楼层20房间', {});\n  if (floor20 && typeof floor20 === 'object') {\n    for (const [roomNumber, data] of Object.entries(floor20)) {\n      const residents: string[] = (data as any)?.入住者 ?? [];\n      if (Array.isArray(residents) && residents.includes(name)) return { kind: 'floor', floor: '20', roomNumber };\n    }\n  }\n\n  const floor19: Record<string, any> = _.get(rooms, '楼层房间.楼层19房间', {});\n  if (floor19 && typeof floor19 === 'object') {\n    for (const [roomNumber, data] of Object.entries(floor19)) {\n      const residents: string[] = (data as any)?.入住者 ?? [];\n      if (Array.isArray(residents) && residents.includes(name)) return { kind: 'floor', floor: '19', roomNumber };\n    }\n  }\n\n  return { kind: 'none' };\n}\n"],"names":["parseWorldTime","dateStr","timeStr","day","m","match","year","Number","month","isFinite","d","Date","isNaN","getTime","Math","floor","parseDateToEpochDay","hm","hour","minute","parseTimeToMinutes","epochMinutes","clampHealth","v","_","clamp","parseTimeStrToMinutes","readShelterScopeFromChat","vars","getVariables","type","raw","get","scope","out","rooms","Object","entries","Array","isArray","filter","x","trim","room","uniq","sortBy","value","normalizeScope","isShelteredForRole","stat_data","roleName","loc","name","kind","entranceA","includes","entranceB","bedroom","bathroom","floor20","roomNumber","data","residents","floor19","findRoleLocation","list","isRoomSheltered","isRoleLike","val","diffRoleTouched","oldRole","newRole","health","isEqual","healthReason","relation","relationTendency","imprint","imprintReason","applyOffstageRoleHealthIfNeeded","rolePath","deltaHours","rules","debug","touched","offstageHealth","console","log","currentHealth","sheltered","computed","dh","delta","reason","decayPer6h","max","recoverPer12h","decayMultiplier","recoverMultiplier","steps","computeOffstageHealthDelta","toFixed","nextHealth","actualDelta","label","split","slice","join","reasonText","set","applyDerivedHealthStatus","role","expected","h","healthCondition","applyDerivedRelationStage","markRaw","stage","mark","relationStageFromImprint","$","async","waitGlobalInitialized","eventOn","Mvu","events","VARIABLE_UPDATE_ENDED","new_variables","old_variables","dateLogic","readDebugFlagsFromChat","oldWorld","oldTimeStr","newTimeStr","oldMinutes","newMinutes","oldDateStr","newDateStr","parsed","parseDateStr","dateObj","setDate","getDate","patched","date","getFullYear","getMonth","oldDays","daysAfter","newWorld","oldParsed","newParsed","diffMinutes","diffWorldHours","old_stat_data","r","readHealthRulesFromChat","reserved","Set","key","has","startsWith","tempNpc"],"ignoreList":[],"sourceRoot":""}