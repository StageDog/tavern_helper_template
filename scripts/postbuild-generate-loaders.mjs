import fs from 'node:fs';
import path from 'node:path';
import crypto from 'node:crypto';

const distRoot = path.join(process.cwd(), 'dist');
if (!fs.existsSync(distRoot)) process.exit(0);

const htmlFiles = fs.globSync('dist/**/index.html', { windowsPathsNoEscape: true });

function sha1Hex(text) {
  return crypto.createHash('sha1').update(text, 'utf8').digest('hex');
}

function makePasteableHtml(html, keySuffix) {
  // SillyTavern stores regex replacement strings as JSON; JSON unescapes sequences like \n, \t, \r, \b, \uXXXX.
  // When the replacement contains a full bundled <script> with JS string literals/regexes using those escapes,
  // the JSON roundtrip turns them into real control chars and the injected script becomes invalid JS.
  //
  // To make the HTML "paste-safe", we keep the injected-data container (type=text/plain) as-is, and wrap all
  // other inline scripts into a base64 payload that is decoded at runtime and executed via a new <script> node.
  const scriptRe = /<script\b([^>]*)>([\s\S]*?)<\/script>/gi;
  let index = 0;
  return html.replace(scriptRe, (full, attrs, body) => {
    const attrText = String(attrs ?? '');
    const hasSrc = /\bsrc\s*=/.test(attrText);
    const typeMatch = attrText.match(/\btype\s*=\s*(['"]?)([^'"\s>]+)\1/i);
    const type = (typeMatch?.[2] ?? '').trim().toLowerCase();

    // Keep external scripts and inert containers untouched.
    if (hasSrc || type === 'text/plain') return full;

    // Empty inline script: keep as-is.
    const code = String(body ?? '');
    if (!code.trim()) return full;

    const key = `th-paste:${keySuffix}:${index++}:${sha1Hex(code)}`;
    const base64 = Buffer.from(code, 'utf8').toString('base64');

    // Important: keep this wrapper free of backslash-escapes like \n, \t, \uXXXX and free of "$1" patterns.
    // The base64 payload contains only [A-Za-z0-9+/=] so it won't trigger ST regex group expansions either.
    return (
      '<script>' +
      '(()=>{' +
      `const k="${key}";` +
      'const seen=globalThis.__tavern_helper_paste_loaded__||(globalThis.__tavern_helper_paste_loaded__=new Set());' +
      'if(seen.has(k))return;seen.add(k);' +
      `const b="${base64}";` +
      'const bin=atob(b);' +
      'const bytes=Uint8Array.from(bin,c=>c.charCodeAt(0));' +
      'const dec=globalThis.TextDecoder?new TextDecoder():null;' +
      'const code=dec?dec.decode(bytes):decodeURIComponent(Array.from(bytes,x=>"%"+x.toString(16).padStart(2,"0")).join(""));' +
      'const s=document.createElement("script");' +
      's.text=code;' +
      'document.body.appendChild(s);' +
      '})();' +
      '</script>'
    );
  });
}

const loaderSource = `// Auto-generated by scripts/postbuild-generate-loaders.mjs
// Loads the sibling index.html, injects its styles, and re-executes its scripts.

const __th_loaded = (globalThis.__tavern_helper_inline_loaders__ ??= new Set());
const __th_key = import.meta.url;
if (__th_loaded.has(__th_key)) {
  // Prevent double-mount if the user pastes the loader twice.
  return;
}
__th_loaded.add(__th_key);

const indexUrl = new URL('./index.html', import.meta.url);

(async () => {
  const html = await fetch(indexUrl).then(r => r.text());
  const doc = new DOMParser().parseFromString(html, 'text/html');

  // Inject styles into the real <head>.
  doc.querySelectorAll('head > style, head > link[rel="stylesheet"]').forEach(node => {
    document.head.appendChild(node);
  });

  // Inject body content (excluding scripts; we recreate them to guarantee execution).
  const scripts = Array.from(doc.body.querySelectorAll('script'));
  for (const s of scripts) s.remove();
  document.body.append(...doc.body.childNodes);

  // Re-run scripts in original order.
  for (const src of scripts) {
    const type = (src.getAttribute('type') ?? '').trim().toLowerCase();

    // Keep injected data container (and any other text/plain scripts) inert.
    if (type === 'text/plain') {
      document.body.appendChild(src);
      continue;
    }

    const s = document.createElement('script');
    if (src.hasAttribute('type')) s.setAttribute('type', src.getAttribute('type'));
    if (src.hasAttribute('nomodule')) s.setAttribute('nomodule', '');
    if (src.hasAttribute('async')) s.setAttribute('async', '');
    if (src.hasAttribute('defer')) s.setAttribute('defer', '');
    if (src.id) s.id = src.id;

    if (src.src) s.src = src.src;
    else s.textContent = src.textContent;

    document.body.appendChild(s);
  }
})().catch(err => console.error('[tavern_helper_template loader] Failed:', err));
`;

let generated = 0;
let pasteGenerated = 0;
for (const htmlFile of htmlFiles) {
  const outDir = path.dirname(path.join(process.cwd(), htmlFile));
  const loaderPath = path.join(outDir, 'loader.js');
  fs.writeFileSync(loaderPath, loaderSource, 'utf8');
  generated += 1;

  // Generate a paste-safe variant for SillyTavern regex replacement fields.
  // It keeps the `$1` placeholder and wraps bundled scripts to avoid JSON unescape corruption.
  try {
    const htmlPath = path.join(process.cwd(), htmlFile);
    const html = fs.readFileSync(htmlPath, 'utf8');
    const keySuffix = path.relative(process.cwd(), htmlPath).replace(/\\/g, '/');
    const pasteHtml = makePasteableHtml(html, keySuffix);
    const pastePath = path.join(outDir, 'paste.html');
    fs.writeFileSync(pastePath, pasteHtml, 'utf8');
    pasteGenerated += 1;
  } catch {
    // ignore
  }
}

console.info(`[postbuild] generated ${generated} loader.js file(s)`);
console.info(`[postbuild] generated ${pasteGenerated} paste.html file(s)`);
